# -*- coding: utf-8 -*-
"""db_ops.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1D9jI67WqpOHRNLTUQrhhzUZEu1oPOHtU
"""

# db_ops.py
from datetime import datetime
from typing import Optional, Dict, Any
import hashlib

from firebase_admin import firestore
from google.cloud import firestore as gcf
from Levenshtein import distance as lev
import firebase_init 
from settings import get_db
_db = get_db()

import os
from google.cloud import firestore

import firebase_admin
from firebase_admin import credentials

_PROJECT_ID = os.getenv("GOOGLE_CLOUD_PROJECT")# or "hallowed-cortex-474405-b4"
_db = firestore.Client(project="genie-hi-front")

if not firebase_admin._apps:
    # Use default creds, but pin project to the same one:
    firebase_admin.initialize_app(options={
        "projectId": "genie-hi-front"
    })

try:
    from google.cloud import firestore as gcf
    _tmp_client = gcf.Client()
    print("DEBUG Firestore project =", _tmp_client.project)
except Exception as e:
    print("DEBUG Firestore project lookup failed:", e)

def uid_from_email(email: str) -> str:
    return hashlib.sha1((email or "anon@example.com").strip().lower().encode()).hexdigest()

def ensure_user_profile(uid: str, email: str):
    _db.collection("users").document(uid).set(
        {"email": email, "created_at": firestore.SERVER_TIMESTAMP}, merge=True
    )

def create_session(uid: str, resume_text: str, jd_text: str,
                   tone_pref: str="", length_pref: str="", highlights: str="",
                   model: str="llm", prompt_version: str="p1.0") -> str:
    ref = _db.collection("users").document(uid).collection("sessions").document()
    ref.set({
        "resume_raw": resume_text,
        "jd_raw": jd_text,
        "tone_pref": tone_pref,
        "length_pref": length_pref,
        "highlights": highlights,
        "model": model,
        "prompt_version": prompt_version,
        "created_at": datetime.utcnow(),
    })
    return ref.id

def save_letter(uid: str, session_id: str, text: str, kind: str):
    assert kind.startswith("edit_v") or kind in ("draft", "final", "suggestions")
    _db.collection("users").document(uid).collection("sessions").document(session_id) \
      .collection("letters").add({"type": kind, "text": text, "created_at": datetime.utcnow()})

def get_latest_draft(uid: str, session_id: str) -> Optional[str]:
    docs = _db.collection("users").document(uid).collection("sessions").document(session_id) \
        .collection("letters").where("type","==","draft") \
        .order_by("created_at", direction=gcf.Query.DESCENDING).limit(1).get()
    return docs[0].to_dict().get("text") if docs else None

def upsert_final_and_metric(uid: str, session_id: str, final_text: str) -> float:
    draft_text = get_latest_draft(uid, session_id) or ""
    d = float(lev(draft_text, final_text or ""))

    # single latest-final doc
    _db.collection("users").document(uid).collection("sessions").document(session_id) \
      .collection("letters").document("latest_final").set({
        "type": "final",
        "text": final_text or "",
        "created_at": datetime.utcnow()
      })

    # metric trail
    _db.collection("users").document(uid).collection("sessions").document(session_id) \
      .collection("metrics").add({
        "name": "edit_distance", "value": d, "created_at": datetime.utcnow()
      })
    return d

def save_feedback(uid: str, user_email: str, session_id: str, thumb: int, reason: str=""):
    _db.collection("users").document(uid).collection("sessions").document(session_id) \
      .collection("feedback").add({"thumb": int(thumb), "reason": reason, "created_at": datetime.utcnow()})

def promote_exemplar(uid: str, final_text: str):
    _db.collection("users").document(uid).collection("exemplars").add({
        "text": final_text or "", "approved_at": datetime.utcnow()
    })


def log_interaction(uid: str, user_email: str,session_id: str, event_type: str, payload: dict):
    doc = {
        "uid": uid,
        "user_email": user_email,
        "session_id": session_id,
        "event_type": event_type,
        "details": payload,
        "ts": firestore.SERVER_TIMESTAMP,
    }
    # single canonical collection name
    return _db.collection("interaction_logs").add(doc)
